# Chapter 7 - 객체 분해

 이번 장은 사람의 기억이 장기 기억과 단기 기억으로 분류되며, 실제로 문제를 해결하기 위해 사용하는 저장소는 장기 기억이 아닌 단기 기억이라는 말로 시작된다.

-**인지 과부하(cognitive overload)**: 문제 해결에 필요한 요소의 수가 단기 기억의 용량을 초과하는 순간 문제 해결 능력이 급격하게 떨어지는 것

-**추상화**: 인지 과부하를 방지하기 위해 단기 기억 안에 보관할 정보의 양을 조절하는 것. 불필요한 정보를 제거하고 현재의 문제 해결에 필요한 핵심만 남기는 작업

-**분해(decomposition)**: 큰 문제를 해결 가능한 작은 문제로 나누는 작업

 추상화와 분해는 인류가 창조한 가장 복잡한 분야인 소프트웨어 개발 영역의 문제를 해결하기 위해 사용돼 왔다.
 
<br>

# 프로시저 추상화와 데이터 추상화

 <br>

-**프로시저 추상화(procedure abstraction)**: 소프트웨어가 무엇을 해야 하는지 추상화

-**데이터 추상화(data abstraction)**: 소프트웨어가 무엇을 알아야 하는지 추상화

<br>
 시스템을 분해하는 방법을 결정하려면 프로시저 추상화를 중심으로 할 것인지, 데이터 추상화를 중심으로 할 것인지 결정해야 한다.

- 프로시저 추상화로 결정
**기능 분해(functional decomposition)** (=**알고리즘 분해(algorithm decomposition)**) 를 수행
- 데이터 추상화로 결정
**데이터 중심으로 타입을 추상화(type abstraction)** 또는 **데이터 중심으로 프로시저 추상화(procedure abstraction)** 중에 선택.
전자를 **추상 데이터 타입**이라고 부르고, 후자를 **객체지향**이라고 부름

<br>
 프로그래밍 언어적인 관점에서 객체지향을 바라보는 일반적인 관점은 데이터 추상화와 프로시저 추상화를 함께 포함한 클래스를 이용해 시스템을 분해하는 것이다.

<br><br>

# 프로시저 추상화와 기능 분해

<br>

- 메인 함수로서의 시스템

 기능은 오랫동안 시스템을 분해하기 위한 기준으로 사용됐으며, 이 같은 시스템 분해 방식을 **알고리즘 분해** 또는 **기능 분해**라고 부른다.

 기능 분해의 관점에서 추상화의 단위는 **프로시저**이고, 프로시저는 잠재적으로 정보은닉의 가능성을 제시한다.

 프로시저 중심의 기능 분해 관점에서 시스템은 필요한 더 작은 작업으로 분해될 수 있는 하나의 커다란 메인함수이며, 전통적인 기능 분해 방법은 **하향식 접근법**이다.

 하향식 접근법에서 정제된 상위 기능은 하나 이상의 더 간단하고 더 구체적이며 덜 추상적인 하위 기능의 집합으로 분해된다.

<br>

- 급여 관리 시스템

 급여 관리 시스템을 예로 들어본다.

 1. '기능 분해 방법'을 사용하면, 최상위의 추상적인 함수 정의부터 시작한다.

> 직원의 급여를 계산한다.

  2. 이제 기능 분해 방법에 따라 이 프로시저를 좀 더 세분화된 절차로 구체화한다.

> 직원의 급여를 계산한다.<br>
     &nbsp;&nbsp;&nbsp;사용자로부터 소득세율을 입력받는다.<br>
     &nbsp;&nbsp;&nbsp;직원의 급여를 계산한다.<br>
     &nbsp;&nbsp;&nbsp;양식에 맞게 결과를 출력한다.<br>

 3. 더 정제 가능한 문장이 존재하면 동일한 과정을 거쳐 구현이 가능할 정도로 충분히 저수준의 문장이 될 때까지 기능을 분해한다.

> 직원의 급여를 계산한다.<br>
     &nbsp;&nbsp;&nbsp;사용자로부터 소득세율을 입력받는다.<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"세율을 입력하세요: "라는 문장을 화면에 출력한다.<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;키보드를 통해 세율을 입력받는다.<br>
     &nbsp;&nbsp;&nbsp;직원의 급여를 계산한다.<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;전역 변수에 저장된 직원의 기본급 정보를 얻는다.<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;급여를 계산한다.<br>
     &nbsp;&nbsp;&nbsp;양식에 맞게 결과를 출력한다.<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"이름: {직원명}, 급여: {계산된 금액}" 형식에 따라 출력 문자열을 생성한다.<br>

<br>

- 급여 관리 시스템 구현

 위에서 분해한 급여 관리 시스템을 코드로 나타내보면 다음과 같다.

> 직원의 급여를 계산한다.

```ruby
def main(name)
end
```

> 직원의 급여를 계산한다.<br>
     &nbsp;&nbsp;&nbsp;사용자로부터 소득세율을 입력받는다.<br>
     &nbsp;&nbsp;&nbsp;직원의 급여를 계산한다.<br>
     &nbsp;&nbsp;&nbsp;양식에 맞게 결과를 출력한다.<br>

```ruby
def main(name)
	taxRate = getTaxRate()
	pay = calculatePayFor(name, taxRate)
	puts(describeResult(name, pay))
end
```

> 직원의 급여를 계산한다.<br>
     &nbsp;&nbsp;&nbsp;사용자로부터 소득세율을 입력받는다.<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"세율을 입력하세요: "라는 문장을 화면에 출력한다.<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;키보드를 통해 세율을 입력받는다.<br>
     &nbsp;&nbsp;&nbsp;직원의 급여를 계산한다.<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;전역 변수에 저장된 직원의 기본급 정보를 얻는다.<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;급여를 계산한다.<br>
     &nbsp;&nbsp;&nbsp;양식에 맞게 결과를 출력한다.<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"이름: {직원명}, 급여: {계산된 금액}" 형식에 따라 출력 문자열을 생성한다.<br>

```ruby
$employees = ["직원A", "직원B", "직원C"]
$basePays = [400, 300, 250]

def main(name)
	taxRate = getTaxRate()
	pay = calculatePayFor(name, taxRate)
	puts(describeResult(name, pay))
end

def getTaxRate()
	print("세율을 입력하세요")
	return get().chomp().to_f()
end

def calculatePayFor(name, taxRate)
	index = $employees.index(name)
	basePay = $basePays[index]
	return basePay - (basePay * taxRate)
end

def describeResult(name, pay)
	return "이름: #{name}, 급여: #{pay}"
end
```

 하향식 기능 분해는 메인 함수를 루트로 하는 트리로 표현할 수 있다. 각 노드는 시스템을 구성하는 하나의 프로시저를 의미한다.

 겉보기에는 구조적이며 체계적으로 보이지만 이 방법은 불규칙하고 불완전한 우리의 세계와 만나는 지점에서 혼란과 동요가 발생한다.

<br>

- 하향식 기능 분해의 문제점

1. 하나의 메인 함수라는 비현실적인 아이디어
 시스템은 시간이 지나면서 지속적으로 새로운 기능을 추가하게 되고, 이것은 시스템이 오직 하나의 메인함수만으로 구현된다는 개념과 모순된다.
 현대적인 시스템은 동등한 수준의 다양한 기능으로 구성되며, 실제 시스템에 정상이랑 존재하지 않는다.

2. 메인 함수의 빈번한 재설계
 하향식 기능 분해의 경우에는 새로운 기능을 추가할 때마다 메인 함수를 수정해야 한다.
 결과적으로 기존 코드를 빈번하게 수정하게 되어 시스템은 변경에 취약해진다.

3. 비즈니스 로직과 사용자 인터페이스의 결합
 하향식 접근법은 비즈니스 로직을 설계하는 초기 단계부터 입력 방법과 출력 양식같은 사용자 인터페이스까지 함께 고민하도록 하기 때문에 코드 안에서 비즈니스 로직과 사용자 인터페이스 로직이 밀접하게 결합된다.
 이는 근본적으로 변경에 불안정한 아키텍처를 낳게 하고, 관심사의 분리라는 아키텍처 설계의 목적을 달성하기 어렵게 만든다.

4. 성급하게 결정된 실행 순서
 설계를 시작하는 시점부터 시스템이 무엇을 해야 하는지가 아니라 어떻게 동작해야 하는지에 집중하도록 만든다.
 하향식 접근법으로 분해한 함수들은 재사용하기 어려우며 이런 모든 문제의 원인은 **결합도**이다. 전체 시스템의 핵심적인 구조를 결정하는 함수들이 데이터와 강하게 결합된다.

5. 데이터 변경으로 인한 파급효과
 하향식 기능 분해의 가장 큰 문제점은 데이터 변경으로 인해 어떤 함수가 영향을 받을지 예상하기 어렵다는 것이다.
 데이터 변경으로 인한 영향을 최소화하려면 잘 정의된 퍼블릭 인터페이스를 통해 데이터에 대한 접근을 통제해야 한다. 이는 후에 **정보 은닉**과 **모듈**이라는 개념이 제시되는 바탕이 된다.

<br>

- 언제 하향식 분해가 유용한가?

 하향식 분해는 작은 프로그램과 개별 알고리즘을 위해서는 유용한 패러다임이다. 이미 해결된 알고리즘을 문서화하고 서술하는 데는 훌륭한 기법이다.

<br><br>

# 모듈

<br>

- 정보 은닉과 모듈

 -**정보 은닉(information hiding)**: 시스템을 모듈 단위로 분해하기 위한 기본 원리로, 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다.

 모듈은 두 가지 비밀을 감춰야 한다. (p.237 ~ 239 코드 참고)

1. 복잡성
2. 변경 가능성

<br>

- 모듈의 장점과 한계

 위의 참고 코드에서 알 수 있는 모듈의 장점

1. 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다.
2. 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.
3. 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다.

 모듈은 기능이 아니라 변경의 정도에 따라 시스템을 분해하며, 모듈들 사이에는 퍼블릭 인터페이스를 통해서만 통신하기 때문에 **높은 응집도**와 **낮은 결합도**를 유지한다.

 하지만 더 높은 추상화를 위해서는 추상 데이터 타입을 사용하는 것이 좋다.

<br><br>

# 데이터 추상화와 추상 데이터 타입

<br>

- 추상 데이터 타입

-**타입(type)**: 변수에 저장할 수 있는 내용물의 종류와 변수에 적용될 수 있는 연산의 가짓수

-**데이터 추상화(data abstraction)**: 프로시저 추상화를 보완하기 위해 제안된 개념

 추상 데이터 타입을 구현할 때 필요한 프로그래밍 언어의 지원

1. 타입 정의를 선언할 수 있어야 한다.
2. 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 한다.
3. 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 한다.
4. 타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 한다.

(p.242 ~ 244 코드 참고) 추상 데이터 타입은 추상화 수준을 향상시키고, 추상 데이터 타입의 기본 의도는 프로그래밍 언어가 제공하는 타입처럼 동작하는 사용자 정의 타입을 추가할 수 있게 하는 것이다.

<br><br>

# 클래스

<br>

- 클래스는 추상 데이터 타입인가?

 명확하게는 클래스와 추상 데이터 타입은 동일하지 않다.

 추상 데이터 타입은 오퍼레이션을 기준으로 타입들을 묶는 반면, 클래스는 타입을 기준으로 오퍼레이션을 묶는다.

 245~246 페이지의 예시를 보면, 추상 데이터 타입인 Employee 타입 안에는 다수의 세부적인 타입(정규직, 아르바이트)이 감추어져 있고, calculatePay()와 monthlyBasePay()를 호출하는 클라이언트는 두 세부적인 직원 타입을 알 수 없다.

 반면, 클래스는 정규직과 아르바이트라는 두 가지 클래스로 분리하고, Employee라는 부모 클래스를 정의한다. 클라이언트가 calculatePay()와 monthlyBasePay()를 호출하면 실제 클래스가 무엇인가에 따라 적절한 절차가 실행된다. 이게 **다형성**이고, 객체지향은 **절차 추상화**라고 할 수 있다.

<br>

- 변경을 기준으로 선택해라

 단순히 클래스를 사용한다는 것이 객체지향 프로그래밍을 한다는 것은 아니다.

-**개방-폐쇄 원칙(Open-Closed Principle, OCP)**: 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성

 추상 데이터 타입과 객체지향 설계는 설계에 요구되는 변경의 압력이 '타입 추가'에 관한 것인지, 아니면 '오퍼레이션 추가'에 관한 것인지에 따라 달라진다.

1. '타입 추가'라는 변경의 압력이 더 강할 때
객체지향을 사용한다. 새로운 클래스를 상속 계층에 추가하기만 하면 된다.
2. '오퍼레이션'이라는 변경의 압력이 더 강할 때
추상 데이터 타입을 사용한다. 객체지향이면 상속 계층에 있는 모든 클래스를 전부 수정해야 하기 때문이다.
