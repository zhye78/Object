# Chapter 15 - 디자인 패턴과 프레임워크

- **디자인 패턴**: 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법으로, 설계를 재사용하는 것이 목적.
- **프레임워크**: 설계와 코드를 함께 재사용하기 위한 것.

 위의 두 가지 모두 14장에서 살펴본 일관성 있는 협력을 위한 방법이다.

# 디자인 패턴과 설계 재사용

 패턴은 한 컨텍스트에서 유용한 동시에 다른 컨텍스트에서도 유용한 아이디어이며, 실무 현장에서 검증되고 입증된 경험의 산물이다.

### 패턴 분류

 패턴은 일반적으로 범위나 적용단계에 따라 아키텍처 패턴, 분석 패턴, 디자인 패턴, 이디엄으로 분류되고, 이 중에서 독특한 설계 문제를 해결하는 목적을 가진 중간 규모 패턴인 디자인 패턴이 가장 널리 알려져 있다.

 디자인 패턴의 상위에는 소프트웨어의 전체 구조를 위한 아키텍처 패턴이 있고, 하위에는 특정 프로그래밍 언어에 국한되는 이디엄이 있으며, 분석 패턴은 이런 기술적인 문제가 아닌 도메인 내의 개념적인 문제를 해결하기 위한 것이다.

### 패턴과 책임-주도 설계

 패턴의 구성 요소는 클래스가 아닌 '역할'이다. Composite 패턴을 예로 들어본다.

(p.517 그림 15.1 참고) 구성 요소인 Component, Leaf 등은 클래스가 아니라 협력에 참여하는 객체들의 역할이다. 따라서 그림 15.2 처럼 하나의 객체가 세 역할 모두를 수행할 수 있다. 또한 반대로 그림 15.3처럼 다수의 클래스가 동일한 역할을 구현할 수도 있다.

 디자인 패턴의 구성요소가 클래스와 메서드가 아닌 역할과 책임이라는 사실을 이해하는 것이 중요.

### 캡슐화와 디자인 패턴

 대부분의 디자인 패턴은 특정한 변경을 캡슐화하기 위한 독자적인 방법을 정의한다.

1. Strategy패턴: (그림 15.4) 할인정책의 종류는 Movie가 참조하는 DiscountPolicy의 서브클래스가 무엇이냐에 따라 결정되고 런타임에 알고리즘 변경 가능
2. Template Method 패턴: (그림 15.5) 알고리즘 캡슐화를 위해 합성이 아닌 상속을 사용함
3. Decorator 패턴: (그림 15.6) 객체의 행동을 동적으로 추가하기 용이하도록 객체 합성 사용
4. Composite 패턴: 객체의 수와 관련된 변경을 캡슐화

### 패턴은 출발점이다

 패턴은 목표 설계에 이를 수 있는 방향을 제시할 뿐, 설계의 목표가 돼서는 안된다. 패턴을 정당한 이유 없이 맹목적으로 사용하면 설계를 복잡하게 만드는 장애물이 된다.

# 프레임워크와 코드 재사용

### 코드 재사용 대 설계 재사용

 디자인 패턴은 언어에 종속적인 구현 코드를 정의하지 않기 때문에 사용 언어에 맞추어 가공해야 한다.

 따라서 재사용 관점에서 설계 재사용보다 더 좋은 방법은 코드 재사용이며, 가장 이상적인 방법은 설계 재사용과 코드 재사용을 적절한 수준으로 조합하는 것이다. → **프레임워크**

 프레임워크는 코드를 재사용함으로써 설계 아이디어를 재사용한다.

### 상위 정책과 하위 정책으로 패키지 분리하기

(p.525 그림 15.7) 구체적인 클래스들은 추상 클래스나 인터페이스에 의존하지만 추상화들은 구체 클래스에 의존하지 않는다.

(p.527 그림 15.8) 변하지 않고 재사용될 가능성이 높은 부분인 상위 정책에 속하는 역할들의 협력 구조와, 변하는 부분인 구체적인 세부 사항을 별도의 패키지로 분리한다.

(p.528 그림 15.9) 상위 정책을 구현하고 있는 패키지를 완벽히 분리해서 별도의 프레임워크로 만든다.

이렇게 프레임워크는 여러 애플리케이션에서 일관성 있는 협력을 구현할 수 있게 해준다.

### 제어 역전 원리

 훌륭한 객체지향 설계는 의존성이 역전된 설계이고, 의존성 역전 원리는 프레임워크의 가장 기본적인 설계 메커니즘이다. 의존성 역전은 의존성의 방향뿐 아니라 제어 흐름의 주체 역시 역전시킨다. 

 **제어 역전 원리(=할리우드 원리)**: 상위 정책이 세부 사항에 의존하는 전통적인 구조에서 애플리케이션의 코드가 직접 라이브러리 등을 호출하는 것과 반대로, 객체지향 구조에서는 프레임워크가 애플리케이션에 속하는 서브클래스의 메서드를 호출하기 때문에 제어 흐름의 주체가 이동한다.